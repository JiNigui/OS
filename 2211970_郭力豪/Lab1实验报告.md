# 实验一实验报告

## 一：实验目的

实验1主要讲解的是中断处理机制。操作系统是计算机系统的监管者，必须能对计算机系统状态的突发变化做出反应，这些系统状态可能是程序执行出现异常，或者是突发的外设请求。当计算机系统遇到突发情况时，不得不停止当前的正常工作，应急响应一下，这是需要操作系统来接管，并跳转到对应处理函数进行处理，处理结束后再回到原来的地方继续执行指令。这个过程就是中断处理过程。

## 二：实验步骤

#### 练习1：理解内核启动中的程序入口操作

阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

###### `la sp, bootstacktop` 指令

- `la` 是 RISC-V 的伪指令，用于加载地址。
- `sp` 是堆栈指针（Stack Pointer）。
- `bootstacktop` 是一个标签，表示内核启动栈的栈顶位置。

指令 `la sp, bootstacktop` 的作用是将标签 `bootstacktop` 的地址加载到堆栈指针 `sp` 中。这意味着在执行这条指令后，栈指针 `sp` 将指向内核栈的顶端。

该指令确保在执行内核初始化代码之前，堆栈指针指向预先分配好的内核启动栈的顶部。这是启动内核的关键步骤，因为在进程切换或调用任何子例程过程中，需要一个有效的栈来存储返回地址、局部变量和其他信息。

###### `tail kern_init` 指令

- `tail` 是 RISC-V 的一个伪指令，等效于跳转并链接（JALR）指令，但它同时会将返回地址寄存器（ra）清零。
- `kern_init` 是一个标签，代表内核初始化函数的入口地址。

指令 `tail kern_init` 将程序的执行流直接跳转到 `kern_init` 函数入口，同时该指令还优化了跳转过程，不会在链式调用中保存返回地址（即不保存调用者的地址）。

该指令应用于 bootloader 内核启动过程，在这种情况下，首次进入内核初始化函数后，没有必要再返回，所以会使用尾调用（tail call）的方式跳转。直接跳转到 `kern_init` 开始执行，而不需要保存返回地址，减小了一些开销。尾调用优化可以减少不必要的栈帧开销，这对于启动代码来说非常重要，因为启动代码希望尽可能简单高效。

#### 练习2：完善中断处理 （需要编程）

请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。

要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

要完成该问题，我们需要在时钟中断处理部分添加以下逻辑：

1. 设置下次时钟中断。

2. 计数器 `ticks` 加一。

3. 当 `ticks` 到达 100 时，调用 `print_ticks` 函数，并将 `num` 加一。

4. 如果 `num` 达到 10，则调用 `sbi_shutdown` 函数关机。

具体实现方法：

在case IRQ_S_TIMER下面添加内容：

```
 clock_set_next_event();
            ticks++;
            if (ticks % TICK_NUM == 0) {
                print_ticks();
                num++;
                if (num >= 10) {
                    sbi_shutdown();
                }
            }
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
```



#### 扩展练习 Challenge1：描述与理解中断流程

回答：描述ucore中处理中断异常的流程（从异常的产生开始），其中mov a0，sp的目的是什么？SAVE_ALL中寄寄存器保存在栈中的位置是什么确定的？对于任何中断，__alltraps 中都需要保存所有寄存器吗？请说明理由

中断可以由外部硬件（如键盘、时钟）或内部软件错误（如程序访问非法地址）触发。处理器响应中断，将控制权转移给对应的中断服务例程。这通常通过查询一个预先设定的中断向量表来完成，该表中包含了不同中断源对应处理函数的地址，跳转到trap函数，为了保护应用程序或其他中断处理程序的执行状态，需要在处理具体的中断之前保存当前的处理器状态。处理完成后，恢复之前的处理器状态，并从中断返回。

mov a0，sp的目的是把保存上下文之后的栈顶指针寄存器赋值给参数寄存器，这样就可以把当前的中断帧作为参数传递给中断处理程序，从而实现对中断的处理。寄存器保存的位置是通过栈顶寄存器sp来索引的，alltraps不需要保存所有寄存器，因为对于某些中断，其处理程序可能只会用到几个寄存器，我们只需要将这些寄存器保存下来即可，并且有很多寄存器的值不会受中断影响而改变，对于这部分寄存器不用保存，以减少程序的空间和时间开销。

#### 扩增练习 Challenge2：理解上下文切换机制

回答：在trapentry.S中汇编代码 csrw sscratch, sp；csrrw s0, sscratch, x0实现了什么操作，目的是什么？save all里面保存了stval scause这些csr，而在restore all里面却不还原它们？那这样store的意义何在呢？

`csrw sscratch, sp`指令将当前的栈指针（`sp`）的值写入系统的`sscratch`寄存器。`sscratch`寄存器在RISC-V体系中通常用于保存某些特定的临时数据，特别是在中断或异常处理时。在本例中，把`sp`的值存入`sscratch`可以在异常处理期间保持对栈的访问，即使中断处理会更改`sp`值。

`csrrw s0, sscratch, x0`指令从`sscratch`寄存器读取值到`s0`寄存器，并将`x0`（始终为零的寄存器）的值写入`sscratch`。此操作的结果是`s0`现在存储了发生异常时的原始栈指针，且`sscratch`被清零。这样做保证了可以随时通过`s0`回溯到原始的栈位置。

以上两条指令主要目的是用于在发生异常或中断时快速且安全地保存和恢复处理器的状态，以及维护任务或线程上下文的连续性。通过利用`sscratch`来临时保存关键的控制信息，可以优化异常处理路径，减少状态损坏的风险，并为后续的中断或异常恢复提供必需的信息。

`stval`（存储最后一次触发异常的地址）和`scause`（存储异常的原因）等控制状态寄存器（CSR）在异常时被保存，主要是为了在异常处理例程中能够引用这些值进行诊断或者适当的处理。`stval`和`scause`为异常处理提供上下文，系统可以通过检查这些值来决定如何响应异常。有时候这些值被用来记录错误或系统状态，用于调试或审计。在许多情况下，`stval`和`scause`在异常处理完毕后不需要恢复到中断或异常发生前的值。异常的性质通常意味着一旦处理完毕，这些信息不再是必需的，因为它们特定于上一次异常的发生。在关键任务代码或操作系统核心的下一个阶段，系统可能不再依赖这些特定的错误状态。

#### 扩展练习Challenge3：完善异常中断

编程完善在触发一条非法指令异常 mret和，在 kern/trap/trap.c的异常处理函数中捕获，并对其进行处理，简单输出异常类型和异常指令触发地址，即“Illegal instruction caught at 0x(地址)”，“ebreak caught at 0x（地址）”与“Exception type:Illegal instruction"，“Exception type: breakpoint”。

```
case CAUSE_ILLEGAL_INSTRUCTION:
		// 非法指令异常处理
		/* LAB1 CHALLENGE3   YOUR CODE : */
	   /*(1)输出指令异常类型（ Illegal instruction）
		*(2)输出异常指令地址
		*(3)更新 tf->epc寄存器
	   */
		cprintf("Exception type:Illegal instruction \n");
		cprintf("Illegal instruction exception at 0x%016llx\n", tf->epc);//采用0x%016llx格式化字符串，用于打印16位十六进制数，这个位置是异常指令的地址,以tf->epc作为参数。
		//%016llx中的%表示格式化指示符的开始，0表示空位补零，16表示总宽度为 16 个字符，llx表示以长长整型十六进制数形式输出。
		tf->epc += 4;//指令长度都为4个字节
		break;
	case CAUSE_BREAKPOINT:
		//断点异常处理
		/* LAB1 CHALLLENGE3   YOUR CODE : */
		/*(1)输出指令异常类型（ breakpoint）
		 *(2)输出异常指令地址
		 *(3)更新 tf->epc寄存器
		*/
		cprintf("Exception type: breakpoint \n");
		cprintf("ebreak caught at 0x%016llx\n", tf->epc);
		tf->epc += 2;//ebreak指令长度为2个字节，为了4字节对齐
		break;
```

**对齐问题**：在更新`tf->epc`时，尽管`ebreak`是2字节的，但通常RISC-V体系结构要求指令地址在最低有效两位是零的，因此指令地址应为4字节对齐。这里的`tf->epc += 2;`可能是基于特定实现的前提，但一般情况下应是`tf->epc += 4;`保持一致性和对齐。
