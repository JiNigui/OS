# Lab0.5实验报告

## 一：实验目的

为了熟悉使用qemu和gdb进行调试工作,使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。

## 二：实验过程

### 使用GDB验证ucore启动流程

进入虚拟机ubuntu，下载lab0.5实验代码文件，选中后在终端打开，按照实验指导手册使用gdb和qemu源码级调试ucore

计算机ucore启动后首先停在程序计数器被初始化的位置（0x1000），由实验指导手册得出这个位置是复位地址，说明cpu上电后首先做的事情就是复位，将各个组件置于初始化状态，并且启动bootloader。

gdb终端信息如下：

```
   0x1000:	auipc	t0,0x0
   0x1004:	addi	a2,t0,40
   0x1008:	csrr	a0,mhartid
   0x100c:	ld	a1,32(t0)
   0x1010:	ld	t0,24(t0)
   0x1014:	jr	t0
   0x1018:	unimp
   0x101a:	0x8000
   0x101c:	unimp
   0x101e:	unimp
    


```

逐一分析这十句代码运行原理

1. **0x1000: auipc t0,0x0**

   - `auipc` (Add Upper Immediate to PC) 指令将当前的PC值加上一个立即数（在本例中是0），并存储到指定寄存器t0中。
   - 这实际上是把当前的PC值（这里是0x1000）存到寄存器 `t0`。
2. **0x1004: addi a2, t0, 40**

   - `addi` (Add Immediate) 指令将寄存器t0中的值加上立即数40，并将结果存储到寄存器 `a2` 中。
3. **0x1008: csrr a0, mhartid**

   - `csrr` (Control and Status Register Read) 指令将控制和状态寄存器 `mhartid` 的值加载到寄存器 `a0`。
   - `mhartid` 通常保存当前的硬件线程ID (hardware thread ID)。
4. **0x100c: ld a1, 32(t0)**
   - `ld` (Load Doubleword) 指令从基地址（t0）加上偏移量32处的内存地址加载一个64位的值到寄存器 `a1` 中。
   - 因为 `t0 = 0x1000`，所以加载自 `0x1000 + 32 = 0x1020` 的值到 `a1`。
5. **0x1010: ld t0, 24(t0)**

   - `ld` (Load Doubleword) 指令从基地址（t0）加上偏移量24处的内存地址加载一个64位的值到寄存器 `t0` 中。
   - 因为 `t0 = 0x1000`，所以加载自 `0x1000 + 24 = 0x1018` 的值到 `t0`。
6. **0x1014: jr t0**

   - `jr` (Jump Register) 指令将无条件地跳转到寄存器 `t0` 中指定的地址。

   - 在前面的指令中，`t0` 的值被设置为 `0x1018` 中存储的那个值，所以程序跳转到该地址
7. **0x1018:unimp;
8. 最终通过jr t0返回到0x80000000处的指令，即为启动bootloader，进入下一阶段



点击si，观察运行情况

```
(gdb) si
0x0000000080000000 in ?? ()

输入命令
(gdb) x/10i $pc
=> 0x80000000:	add	s0,a0,zero
   0x80000004:	add	s1,a1,zero
   0x80000008:	add	s2,a2,zero
   0x8000000c:	jal	ra,0x80000580
   0x80000010:	add	a6,a0,zero
   0x80000014:	add	a0,s0,zero
   0x80000018:	add	a1,s1,zero
   0x8000001c:	add	a2,s2,zero
   0x80000020:	li	a7,-1
   0x80000022:	beq	a6,a7,0x8000002a

```

保存参数: 前三条指令将 `a0`、`a1` 和 `a2` 的值保存到 `s0`、`s1` 和 `s2`，这可能是为了保护这些参数的值，以便稍后使用。 用 `jal` 指令跳转到地址 `0x80000580` 处的代码执行，并保存返回地址。从子程序返回后，继续执行原代码。返回后，将保存的参数从 `s0`、`s1`、`s2` 恢复到 `a0`、`a1`、`a2`。

这些是RISC-V的cpu加电后的几条指令，由RISC-V架构中的Bootloader即OpenSBI获取计算机控制权后负责实现，位于物理地址0x80000000处。包括了加载启动代码的地址、设置寄存器、获取处理器信息等。在启动阶段，这些指令会被处理器执行，从而使处理器进入正确的状态以启动操作系统或其他应用程序。

接下来在0x80200000处设置断点，并利用continue命令运行到这个位置，查看未来十条指令

```
   0x80200000 <kern_entry>:     auipc   sp,0x3
   0x80200004 <kern_entry+4>:   mv      sp,sp
   0x80200008 <kern_entry+8>:   j       0x8020000a <kern_init>
   0x8020000a <kern_init>:      auipc   a0,0x3
   0x8020000e <kern_init+4>:    addi    a0,a0,-2
   0x80200012 <kern_init+8>:    auipc   a2,0x3
   0x80200016 <kern_init+12>:   addi    a2,a2,-10
   0x8020001a <kern_init+16>:   addi    sp,sp,-16
   0x8020001c <kern_init+18>:   li      a1,0
   0x8020001e <kern_init+20>:   sub     a2,a2,a0
```

逐一分析十条指令：

0x80200000 <kern_entry>: auipc sp, 0x3

`auipc` 是“Add Upper Immediate to PC”的缩写，RISC-V 指令。在这里，它用来加载当前 PC 寄存器的高20位地址加上立即数至目的寄存器。

auipc sp, 0x3`：将PC（程序计数器）的高20位地址加上 `0x3 << 12` 的结果存储到 `sp`（堆栈指针）寄存器。这通常是为了定位一个偏移地址。

0x80200004 <kern_entry+4>: mv sp, sp

`mv` 是“move”的简写。这里是将 `sp` 赋值给 `sp` 本身，实际上不是一个有用的操作，可能是一个占位符指令，用来对齐代码或其他目的。

0x80200008 <kern_entry+8>: j 0x8020000a <kern_init>

`j` 是“jump”的缩写，表示无条件跳转到指定地址。

j 0x8020000a 跳转到0x8020000a`，即 `kern_init` 位置。

0x8020000a <kern_init>: auipc a0, 0x3

再次使用 `auipc` 指令。

auipc a0, 0x3`：将PC的值加上 `0x3 << 12` 的高20位结果存储到寄存器 `a0`。

0x8020000e <kern_init+4>: addi a0, a0, -2

`addi` 是“add immediate”指令，表示将立即数加到寄存器值上。

addi a0, a0, -2`：将 `a0` 寄存器的值加上 `-2`。这使得 `a0` 地址更精确。

0x80200012 <kern_init+8>: auipc a2, 0x3

再次使用 `auipc` 指令。

auipc a2, 0x3`：将PC的值加上 `0x3 << 12` 的高20位结果存储到寄存器 `a2`。

0x80200016 <kern_init+12>: addi a2, a2, -10

`addi` 指令使用立即数计算。

addi a2, a2, -10`：将 `a2` 寄存器的值加上 `-10`。同样，这使 `a2` 地址更加精确。

0x8020001a <kern_init+16>: addi sp, sp, -16

调整堆栈指针的位置。

addi sp, sp, -16`：将堆栈指针 `sp` 的位置减去 16 个字节。这通常用于为函数调用设置堆栈帧。

0x8020001c <kern_init+18>: li a1, 0

`li` 是“load immediate”的缩写，表示将立即数加载到寄存器中。

li a1, 0`：将常数 `0` 加载进寄存器 `a1`。

0x8020001e <kern_init+20>: sub a2, a2, a0

sub 是“subtract”的缩写。

sub a2, a2, a0`：计算 `a2 - a0` 并将结果存储在 `a2` 寄存器中。

这段代码主要通过一系列`auipc`指令来生成偏移地址，调整寄存器值，并为下一步的初始化做准备。使用堆栈指针调整（sp）来准备堆栈帧，加载一些立即数到寄存器，最后进行一个简单的减法操作。这些步骤通常用于内核初始化，设置必要的寄存器值和堆栈空间，为后续更高层次的功能做准备。

### 启动过程总结

在 Qemu 开始执行任何指令之前，首先进行复位，然后两个文件将被加载到 Qemu 的物理内存中：即作为 bootloader 的 OpenSBI.bin 被加载到物理内存以物理地址 0x80000000 开头的区域上，然后内核镜像 os.bin 被加载到以物理地址 0x80200000 开头的区域上。



## 三：相关概念总结：

### 1. **QEMU 和虚拟化**

- **QEMU：** QEMU（Quick EMUlator）是一款开源的虚拟化软件，能够模拟各种 CPU 和外围设备，创建虚拟机环境。它主要用于运行非原生操作系统，例如在x86系统上运行RISC-V、ARM等架构的操作系统。
- **虚拟化：** 虚拟化指的是利用虚拟化技术在一个物理硬件上创建多个虚拟机的技术。它可以帮助开发者在不改变实际物理硬件的情况下调试和开发操作系统。

### 2. **GDB 调试**

- **GDB（GNU Debugger）：** GDB 是 GNU 项目的调试器，广泛用于调试程序和分析软件行为。它支持多种语言和平台，可以远程调试系统内核以及用户态程序。
- **远程调试：** 通过 GDB 和 QEMU 的结合，开发者可以远程调试运行在虚拟机中的操作系统。通过 QEMU 的 GDB 服务器功能，可以使得 GDB 连接到 QEMU 提供的调试接口，从而控制虚拟机中的代码执行。

### 3. **复位 (Reset) 流程**

- **系统复位：** 在 QEMU 启动虚拟机时，首先会执行复位操作。复位过程通常会初始化硬件设备、设置处理器状态，并重置系统寄存器。
- **复位向量：** 复位后，处理器通常会跳转到一个特定的地址开始执行代码，这个地址被称为复位向量（Reset Vector）。

### 4. **加载内存映像**

- Bootloader（引导加载程序）：

   

  Bootloader 是在操作系统内核加载之前首先运行的程序。它负责初始化硬件、设置处理器工作模式、加载并启动操作系统内核。

  - 在这个实验中，OpenSBI.bin 充当了 bootloader，被加载到物理地址 0x80000000。

- 内核映像：

   

  操作系统内核的二进制映像（os.bin）包含了操作系统的核心代码和数据。内核在 bootloader 初始化后被加载，并运行于更高的内存地址空间。

  - 在这个实验中，os.bin 被加载到物理地址 0x80200000。

### 5. **内存布局**

- **物理内存地址：** 这是计算机系统硬件层面的内存地址。在 QEMU 中，两个文件（OpenSBI.bin 和 os.bin）被加载到物理地址空间的特定位置。
- **虚拟内存地址：** 大多数现代操作系统会将物理内存地址映射到虚拟地址空间，以简化内存管理和提供更好的保护。
- **地址映射：** 在这次实验中，需要明确物理内存和各个组件加载地址间的关系，例如 OpenSBI.bin 在 0x80000000 和os.bin 在 0x80200000。

### 6. **OpenSBI（Open Supervisor Binary Interface）**

- **OpenSBI：** OpenSBI 是基于 RISC-V 架构的一个重要组件，提供了从 bootloader 到操作系统的一些基本功能接口。它负责处理一些机器模式下的操作，将其封装为操作系统可以调用的接口。
- **M模式（Machine Mode）：** RISC-V 的特权层次中最高级的模式，通常由OpenSBI 或其它引导代码运行。然后，它会切换到更低的特权级模式（如S模式）运行实际的内核代码。

​     

​     

​     

​       

​     
